stages:
  - scan_sast
  - build
  - scan_security
  - security_policy_check
  - public_report
  - deploy
  - dast_testing
  - check-pods-status

variables:
 URL_DOMAIN_DEFECTDOJO: $URL_DOMAIN_DEFECTDOJO
 URL_DOMAIN_DEPENDENCYTRACK: $URL_DOMAIN_DEPENDENCYTRACK
 TOKEN_DEPENDENCYTRACK: $TOKEN_DEPENDENCYTRACK
 TOKEN_DEFECTDOJO: $TOKEN_DEFECTDOJO
 PROJECT_NAME: $PROJECT_NAME
 ID_ENGAGEMENT: $ID_ENGAGEMENT
 TAG_LATEST: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_NAME:latest
 TAG_COMMIT: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_NAME:$CI_COMMIT_SHORT_SHA

 # Security Policy Configuration
 FAIL_ON_HIGH_CRITICAL: "${FAIL_ON_HIGH_CRITICAL:-true}"
 FAIL_ON_MEDIUM: "${FAIL_ON_MEDIUM:-false}"
 SLACK_WEBHOOK_URL: "${SLACK_WEBHOOK_URL}"
 SLACK_CHANNEL: "${SLACK_CHANNEL:-#security-alerts}"

# OWASP ZAP DAST Configuration
ZAP_API_KEY: "${ZAP_API_KEY}"
DAST_USERNAME: "${DAST_USERNAME}"
DAST_PASSWORD: "${DAST_PASSWORD}"
ZAP_SCAN_DEPTH: "${ZAP_SCAN_DEPTH:-5}"
ZAP_THREADS: "${ZAP_THREADS:-5}"
ZAP_EXCLUDE_URLS: "${ZAP_EXCLUDE_URLS:-.*\\.css$,.*\\.js$,.*\\.png$,.*\\.jpg$,.*\\.gif$,.*\\.svg$}"


.default:rule:
  rules:
   - if: $CI_COMMIT_BRANCH == "deploy_prod"
     variables:
       KUBE_CONTEXT: poc-project:poc-project-agent
       DEPLOYMENT_NAMESPACE: poc-project-prod
       DEPLOY_MANIFEST_PATH: outsource/poc-project/yaml-poc-projectphp-deploy-prod
       DEPLOY_MANIFEST: yaml-poc-projectphp-deploy-prod
       DEPLOY_YAML: yaml-poc-projectphp-deploy-prod/yaml/
       DEPLOY_ENV: yaml-poc-projectphp-deploy-prod/env/       
       SECRET_NAME: poc-project-secret-env
       URL: https://poc-project.com/poc-project
   - if:  $CI_COMMIT_BRANCH == "deploy_demo"
     variables:
       KUBE_CONTEXT: poc-project:poc-project-agent
       DEPLOYMENT_NAMESPACE: poc-project-demo
       DEPLOY_MANIFEST_PATH: outsource/poc-project/yaml-poc-projectphp-deploy-demo
       DEPLOY_MANIFEST: yaml-poc-projectphp-deploy-demo
       DEPLOY_YAML: yaml-poc-projectphp-deploy-demo/yaml/
       DEPLOY_ENV: yaml-poc-projectphp-deploy-demo/env/
       SECRET_NAME: poc-project-secret-env       
       URL: https://poc-project.demo.com


.kube-context:
  before_script:
  - if [ -n "$KUBE_CONTEXT" ]; then kubectl config use-context "$KUBE_CONTEXT"; fi

.kaniko-build: &kaniko-build
  - |
    /kaniko/executor \
    --cache-copy-layers=false \
    --snapshot-mode=redo \
    --cache-dir=/kaniko/cache \
    --use-new-run \
    --cache=true \
    --cache-repo=$CI_REGISTRY_IMAGE/kaniko_caches \
    --cleanup \
    --context $CI_PROJECT_DIR \
    --dockerfile $CI_PROJECT_DIR/Dockerfile \
    --destination $CI_REGISTRY_IMAGE:$IMAGE_TAG \
    --destination $CI_REGISTRY_IMAGE:latest

clone_script_repo:
  stage: scan_sast
  image: 
     name: alpine/git:latest
     entrypoint: [""]
  script:
    - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@poc-project.com/poc-project/template-scan-security.git scripts
    - ls
    - pwd
  extends: 
    - .default:rule
  artifacts:
    name: "global-scripts"
    paths:
      - "scripts/"
    expire_in: 1 week
  when: on_success
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


üóùÔ∏ègitleaks-secret-scan:
  stage: scan_sast
  image:
    name: zricethezav/gitleaks
    entrypoint: [""]
  extends: 
    - .default:rule
  tags:
    - docker
  script:
    - gitleaks detect --verbose --source . -f json -r gitleaks.json || exit 0
  needs:
    - job: clone_script_repo
      artifacts: true
  allow_failure: true
  artifacts:
    when: always
    paths:
      - gitleaks.json
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


üêûsemgrep-SAST-scan:
  stage: scan_sast
  image: semgrep/semgrep
  extends:
    - .default:rule
  tags:
    - docker
  variables:
    SEMGREP_RULES: >
            p/nodejs
            p/express
            p/javascript
            p/security
            p/owasp-top-ten
            p/cwe-top-25
            p/r2c-security-audit
            # Additional rules
            p/xss
            p/sql-injection
            p/command-injection
            p/secrets
            p/trailofbits
            p/dockerfile
            p/npm-audit

  script:
    - echo "üîç Running Semgrep SAST scan with Node.js rules..."
    - semgrep --config=$SEMGREP_RULES --json --output=semgrep.json . || echo "Semgrep scan completed with findings"
    # Also run with custom Node.js config if available
    - if [ -f "scripts/semgrep-nodejs-config.yaml" ]; then semgrep --config=scripts/semgrep-nodejs-config.yaml --json --output=semgrep_nodejs.json . || echo "Custom Node.js scan completed"; fi
  needs:
    - job: clone_script_repo
      artifacts: true
  allow_failure: true
  artifacts:
    when: always
    paths:
      - semgrep.json
      - semgrep_nodejs.json
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

üõ°Ô∏ètrivy-fs-scan:
  image: alpine:3.20
  extends: 
    - .default:rule
  variables:
    TRIVY_VERSION: v0.50.0 #Please refer release version here https://github.com/aquasecurity/trivy/releases
  stage: scan_sast
  tags:
    - docker
  before_script:
    - apk update && apk add aws-cli bash curl wget ca-certificates gnupg lsb-release
    - ls
    - chmod +x -R scripts/* # Fixing scripts permission
  script:
    - scripts/trivy-scan-fs.sh
  needs:
    - job: clone_script_repo
      artifacts: true
  artifacts:
    when: always
    paths:
      - trivy_fs_report.json
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

syft_sbom:
  image:
    name: registry.gitlab.com/gitlab-ci-utils/container-images/syft:latest
    entrypoint: [""]
  extends: 
    - .default:rule
  stage: scan_sast
  tags:
    - docker
  needs: []
  script:
    - /syft/syft $CI_PROJECT_DIR -o cyclonedx-json=syft.cdx.json
  allow_failure: true
  artifacts:
    when: always
    paths:
      - syft.cdx.json
    reports:
      cyclonedx:
        - syft.cdx.json
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


# ===========================================
# NODE.JS BUILD STAGE
# ===========================================
build_nodejs:
  stage: build
  image: node:18-alpine
  extends:
    - .default:rule
  tags:
    - docker
  cache:
    key: "npm-cache-${CI_PROJECT_ID}-${CI_COMMIT_REF_SLUG}"
    paths:
      - .npm/
      - node_modules/
    policy: pull-push
  before_script:
    - npm config set cache .npm
    - echo "Node.js version: $(node --version)"
    - echo "NPM version: $(npm --version)"
  script:
    - echo "üî® Building Node.js application..."
    - npm ci --cache .npm --prefer-offline
    - echo "üîç Running security audit..."
    - npm audit --audit-level=high || echo "Security audit completed with findings"
    - echo "üß™ Running linting..."
    - npm run lint:check
    - echo "üß™ Running tests..."
    - npm run test
    - echo "üì¶ Building application..."
    - npm run build
    - echo "‚úÖ Node.js build completed successfully"
  artifacts:
    paths:
      - dist/
      - node_modules/
      - coverage/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit:
        - junit.xml
    expire_in: 1 hour
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

build:image:
  stage: build
  image:
    name: gcr.io/kaniko-project/executor:debug
    entrypoint: [""]
  tags:
     - docker
  extends:
    - .default:rule
  needs:
    - build_nodejs
  before_script:
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"$CI_REGISTRY\":{\"username\":\"$CI_REGISTRY_USER\",\"password\":\"$CI_REGISTRY_PASSWORD\"}}}" > /kaniko/.docker/config.json
    - export IMAGE_TAG=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
  script:
    - *kaniko-build
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


üõ°Ô∏ètrivy-docker-scan:
  stage: scan_security
  image: docker:26-cli
  services:
    - name: docker:26-dind
      alias: docker
      command: ["--tls=false"]
  extends: 
    - .default:rule
  needs: ["clone_script_repo", "build:image"]
  allow_failure: true
  variables:
    TRIVY_VERSION: v0.58.1
    IMAGE_TAG: "${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}"
    DOCKER_DRIVER: overlay2
    # Use non-TLS connection for better compatibility
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_VERIFY: ""
    DOCKER_CERT_PATH: ""
  cache:
    key: "trivy-docker-cache-${CI_PROJECT_ID}-${CI_COMMIT_REF_SLUG}"
    paths:
      - .trivycache/
    policy: pull-push
  before_script:
    - apk update && apk add --no-cache bash curl wget ca-certificates gnupg
    - chmod +x -R scripts/*
    # Wait for Docker daemon
    - |
      echo "Waiting for Docker daemon..."
      for i in $(seq 1 60); do
        if docker version >/dev/null 2>&1; then
          echo "Docker daemon is ready"
          break
        fi
        echo "Waiting for Docker daemon... ($i/60)"
        sleep 3
        if [ $i -eq 60 ]; then
          echo "ERROR: Docker daemon failed to start after 3 minutes"
          exit 1
        fi
      done
    # Verify image configuration
    - |
      export IMAGE_TAG=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
      echo "Image tag: $IMAGE_TAG"
      echo "Full image: $CI_REGISTRY_IMAGE:$IMAGE_TAG"
      if [ -z "$IMAGE_TAG" ]; then
        echo "ERROR: IMAGE_TAG is empty"
        exit 1
      fi
  script:
    - |
      export IMAGE_TAG=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
      FULL_IMAGE="$CI_REGISTRY_IMAGE:$IMAGE_TAG"

      echo "Logging in to registry..."
      echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"

      echo "Pulling image: $FULL_IMAGE"
      if docker pull "$FULL_IMAGE"; then
        echo "Image pulled successfully"
        scripts/trivy-scan-docker.sh "$FULL_IMAGE"
      else
        echo "ERROR: Failed to pull image: $FULL_IMAGE"
        echo "Available tags in registry:"
        # Create empty report for consistency
        echo '{"Results":[],"SchemaVersion":2}' > trivy_images_report.json
        echo "WARNING: Continuing with empty report due to missing image"
        exit 0
      fi
  artifacts:
    when: always
    expire_in: 1 day
    paths:
      - trivy_images_report.json
      - .trivycache/
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


upload_reports_defectdojo:
  stage: public_report
  image: python:3.11-alpine
  extends:
    - .default:rule
  tags:
    - docker
  needs: ["clone_script_repo","üóùÔ∏ègitleaks-secret-scan", "üêûsemgrep-SAST-scan", "üõ°Ô∏ètrivy-fs-scan", "üõ°Ô∏ètrivy-docker-scan", "üï∑Ô∏èdast-zap-baseline", "security_policy_check"]
  when: always
  before_script:
    - apk add --no-cache curl
    - pip3 install requests
    - chmod +x scripts/upload-reports-enhanced.py
  script:
    - |
      echo "üì§ Uploading security reports to DefectDojo..."

      # Enhanced DefectDojo upload with auto-creation
      if [ -n "$URL_DOMAIN_DEFECTDOJO" ] && [ -n "$TOKEN_DEFECTDOJO" ]; then
        echo "Using enhanced DefectDojo integration with auto-creation..."

        # Use enhanced script with all available reports
        python3 scripts/upload-reports-enhanced.py \
          "http://$URL_DOMAIN_DEFECTDOJO" \
          "$TOKEN_DEFECTDOJO" \
          "$PROJECT_NAME" \
          gitleaks.json \
          semgrep.json \
          semgrep_nodejs.json \
          trivy_fs_report.json \
          trivy_images_report.json \
          gl-dast-report.json \
          gl-dast-report.xml \
          dependency_track_findings.json \
          security_summary.json

      else
        echo "‚ö†Ô∏è  DefectDojo configuration not found, skipping upload..."
        echo "Required variables: URL_DOMAIN_DEFECTDOJO, TOKEN_DEFECTDOJO, PROJECT_NAME"
      fi
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

# ===========================================
# SECURITY POLICY CHECK
# ===========================================
security_policy_check:
  stage: security_policy_check
  image: python:3.11-alpine
  extends:
    - .default:rule
  tags:
    - docker
  needs:
    - job: üóùÔ∏ègitleaks-secret-scan
      artifacts: true
    - job: üêûsemgrep-SAST-scan
      artifacts: true
    - job: üõ°Ô∏ètrivy-fs-scan
      artifacts: true
    - job: üõ°Ô∏ètrivy-docker-scan
      artifacts: true
    - job: syft_sbom
      artifacts: true
  before_script:
    - apk add --no-cache bash jq
    - chmod +x scripts/security-policy-check.sh
  script:
    - scripts/security-policy-check.sh
  artifacts:
    when: always
    paths:
      - security_summary.json
    reports:
      sast: security_summary.json
    expire_in: 1 week
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

# ===========================================
# ENHANCED DEPENDENCY-TRACK INTEGRATION
# ===========================================
dependencytrack_publish:
  stage: public_report
  image: alpine:latest
  extends:
    - .default:rule
  tags:
    - docker
  needs:
    - job: syft_sbom
      artifacts: true
    - job: build_nodejs
      artifacts: true
  before_script:
    - apk add --no-cache curl jq python3
    - echo "Installing CycloneDX generator..."
    - pip3 install cyclonedx-bom
  allow_failure: true
  script:
    - |
      echo "üîç Enhanced Dependency-Track SBOM Processing..."

      # Configuration
      DT_URL="${URL_DOMAIN_DEPENDENCYTRACK}"
      DT_API_KEY="${TOKEN_DEPENDENCYTRACK}"
      PROJECT_NAME="${PROJECT_NAME:-nodejs-sast-app}"
      PROJECT_VERSION="${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHORT_SHA}"
      BOM_FILE="syft.cdx.json"

      if [ -z "$DT_URL" ] || [ -z "$DT_API_KEY" ]; then
        echo "‚ö†Ô∏è  Dependency-Track configuration not found, skipping..."
        echo "Required variables: URL_DOMAIN_DEPENDENCYTRACK, TOKEN_DEPENDENCYTRACK"
        exit 0
      fi

      echo "üìã Dependency-Track Configuration:"
      echo "   URL: $DT_URL"
      echo "   Project: $PROJECT_NAME"
      echo "   Version: $PROJECT_VERSION"
      echo "   SBOM File: $BOM_FILE"

      # Check if SBOM file exists and is valid
      if [ ! -f "$BOM_FILE" ] || [ ! -s "$BOM_FILE" ]; then
        echo "‚ö†Ô∏è  SBOM file not found or empty: $BOM_FILE"
        echo "Generating new SBOM from Node.js project..."

        # Generate SBOM using CycloneDX if Syft SBOM is not available
        if [ -f "package.json" ]; then
          cyclonedx-bom -o cyclonedx-bom.json
          BOM_FILE="cyclonedx-bom.json"
          echo "‚úÖ Generated new SBOM: $BOM_FILE"
        else
          echo "‚ùå Cannot generate SBOM - no package.json found"
          exit 1
        fi
      fi

      # Validate SBOM file
      if ! python3 -c "import json; json.load(open('$BOM_FILE'))" 2>/dev/null; then
        echo "‚ùå Invalid JSON in SBOM file: $BOM_FILE"
        exit 1
      fi

      echo "üì§ Submitting SBOM to Dependency-Track..."

      # Submit SBOM to Dependency-Track
      RESPONSE=$(curl -s -w "%{http_code}" -o dt_response.json \
        -X POST "${DT_URL}/api/v1/bom" \
        -H "Content-Type: multipart/form-data" \
        -H "X-API-Key: ${DT_API_KEY}" \
        -F "projectName=${PROJECT_NAME}" \
        -F "projectVersion=${PROJECT_VERSION}" \
        -F "autoCreate=true" \
        -F "bom=@${BOM_FILE}")

      HTTP_CODE="${RESPONSE: -3}"

      if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
        echo "‚úÖ SBOM submitted successfully to Dependency-Track"

        # Extract project information from response
        if [ -f "dt_response.json" ] && [ -s "dt_response.json" ]; then
          PROJECT_UUID=$(cat dt_response.json | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(data.get('uuid', ''))
except:
    pass
" 2>/dev/null || echo "")

          if [ -n "$PROJECT_UUID" ]; then
            echo "üîó Project UUID: $PROJECT_UUID"

            # Wait for analysis to complete
            echo "‚è≥ Waiting for Dependency-Track analysis..."
            sleep 30

            # Get vulnerability findings
            echo "üìä Retrieving vulnerability analysis..."
            curl -s -H "X-API-Key: ${DT_API_KEY}" \
              "${DT_URL}/api/v1/finding/project/${PROJECT_UUID}" \
              -o dependency_track_findings.json

            if [ -f "dependency_track_findings.json" ] && [ -s "dependency_track_findings.json" ]; then
              FINDINGS_COUNT=$(cat dependency_track_findings.json | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    print(len(data) if isinstance(data, list) else 0)
except:
    print(0)
" 2>/dev/null || echo 0)

              echo "‚úÖ Retrieved $FINDINGS_COUNT vulnerability findings from Dependency-Track"
            else
              echo "‚ö†Ô∏è  No findings retrieved from Dependency-Track"
              echo '{"findings": []}' > dependency_track_findings.json
            fi
          fi
        fi

      else
        echo "‚ùå Failed to submit SBOM to Dependency-Track (HTTP $HTTP_CODE)"
        if [ -f "dt_response.json" ]; then
          echo "Response: $(cat dt_response.json)"
        fi
        exit 1
      fi

      echo "üéâ Dependency-Track integration completed successfully!"
  artifacts:
    when: always
    paths:
      - syft.cdx.json
      - cyclonedx-bom.json
      - dependency_track_findings.json
      - dt_response.json
    expire_in: 1 week
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL


clone:manifest:
   stage: deploy
   tags:
      - docker
   image: 
     name: alpine/git:latest
     entrypoint: [""]
   extends: 
    - .default:rule
   script:
     - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}@poc-project.com/$DEPLOY_MANIFEST_PATH.git
   artifacts:
     paths:
       - $DEPLOY_MANIFEST
     expire_in: 1h

# Deploy application on K8s cluster using kubectl
deploy:to:k8s:
  stage: deploy
  extends:
    - .default:rule
    - .kube-context
  needs:
    - clone:manifest
  image:
    name: poc-project.com/poc-project/custom-kubectl:latest
    entrypoint: [""]
  tags:
     - docker
  script:
  # Read variable create secret.yaml and deploy on k8s
    - |
        lines=$(base64 $DEPLOY_ENV/.env | tr -d \\n)
        cat <<EOF | kubectl apply -f -
        apiVersion: v1
        data:
            .env: $lines
        kind: Secret
        metadata:
            name: $SECRET_NAME
            namespace: $DEPLOYMENT_NAMESPACE
        EOF

    - ls
    - export IMAGE_TAG=${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
    - kubectl apply -f  $DEPLOY_YAML --namespace=$DEPLOYMENT_NAMESPACE # Directory where yamls are placed in repo
    - kubectl --namespace=$DEPLOYMENT_NAMESPACE set image deployment/poc-project-deployment poc-project-app=poc-project.com/poc-project-php:$IMAGE_TAG
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

check-pods-status:
    stage: check-pods-status
    extends:
     - .default:rule
     - .kube-context
    needs:
     - deploy:to:k8s
    image:
      name: poc-project.com/poc-project/custom-kubectl:latest
      entrypoint: [""]
    script:
      # Check Status Pod
      - sleep 60
      - labels=$(kubectl describe deployment/poc-project-deployment -n $DEPLOYMENT_NAMESPACE | grep Labels | grep appName | awk '{print $2}')
      - kubectl get pods -l "$labels" -n $DEPLOYMENT_NAMESPACE
    environment:
      name: $DEPLOYMENT_NAMESPACE
      url: $URL

# ===========================================
# OWASP ZAP DYNAMIC APPLICATION SECURITY TESTING (DAST)
# ===========================================
üï∑Ô∏èdast-zap-baseline:
  stage: dast_testing
  image: owasp/zap2docker-stable
  extends:
    - .default:rule
  needs:
    - job: deploy:to:k8s
      artifacts: false
    - job: check-pods-status
      artifacts: false
  tags:
    - docker
  variables:
    # Target configuration
    TARGET_URL: "$URL"
    ZAP_API_KEY: "$ZAP_API_KEY"

    # Advanced Scan Configuration
    ZAP_SCAN_DEPTH: "${ZAP_SCAN_DEPTH:-5}"
    ZAP_HOST_PER_SCAN: "${ZAP_HOST_PER_SCAN:-1}"
    ZAP_THREADS: "${ZAP_THREADS:-5}"

    # Performance Optimization
    ZAP_MAX_DURATION: "${ZAP_MAX_DURATION:-1800}"  # 30 minutes in seconds
    ZAP_DELAY_MS: "${ZAP_DELAY_MS:-0}"           # Delay between requests (ms)
    ZAP_AJAX_SPIDER_ENABLED: "${ZAP_AJAX_SPIDER_ENABLED:-true}"
    ZAP_AJAX_SPIDER_MAX_DURATION: "${ZAP_AJAX_SPIDER_MAX_DURATION:-1800}"
    ZAP_BROWSER_ID: "${ZAP_BROWSER_ID:-chrome-headless}"

    # Advanced Spider Configuration
    ZAP_SPIDER_MAX_DEPTH: "${ZAP_SPIDER_MAX_DEPTH:-10}"
    ZAP_SPIDER_MAX_CHILDREN: "${ZAP_SPIDER_MAX_CHILDREN:-100}"
    ZAP_SPIDER_ACCEPT_COOKIES: "${ZAP_SPIDER_ACCEPT_COOKIES:-true}"
    ZAP_SPIDER_HANDLE_OAUTH: "${ZAP_SPIDER_HANDLE_OAUTH:-true}"
    ZAP_SPIDER_HANDLE_PARAMETERS_DATA: "${ZAP_SPIDER_HANDLE_PARAMETERS_DATA:-true}"

    # Advanced Authentication Configuration
    ZAP_AUTH_METHOD: "${ZAP_AUTH_METHOD:-form}"
    ZAP_AUTH_URL: "${ZAP_AUTH_URL:-$URL/login}"
    ZAP_AUTH_USERNAME: "${DAST_USERNAME}"
    ZAP_AUTH_PASSWORD: "${DAST_PASSWORD}"
    ZAP_AUTH_USERNAME_FIELD: "${ZAP_AUTH_USERNAME_FIELD:-username}"
    ZAP_AUTH_PASSWORD_FIELD: "${ZAP_AUTH_PASSWORD_FIELD:-password}"
    ZAP_AUTH_TOKEN: "${DAST_TOKEN}"
    ZAP_AUTH_HEADER: "${ZAP_AUTH_HEADER:-Authorization: Bearer $DAST_TOKEN}"
    ZAP_AUTH_COOKIES: "${ZAP_AUTH_COOKIES}"
    ZAP_AUTH_VERIFY_URL: "${ZAP_AUTH_VERIFY_URL:-$URL/dashboard}"
    ZAP_AUTH_LOGOUT_URL: "${ZAP_AUTH_LOGOUT_URL:-$URL/logout}"

    # Advanced Exclusions and Scope Configuration
    ZAP_EXCLUDE_URLS: "${ZAP_EXCLUDE_URLS:-.*\\.css$,.*\\.js$,.*\\.png$,.*\\.jpg$,.*\\.gif$,.*\\.svg$,.*logout.*,.*admin.*,.*settings.*,.*profile.*,.*account.*}"
    ZAP_EXCLUDE_PARAMS: "${ZAP_EXCLUDE_PARAMS:-session.*,csrf.*,auth.*,token.*,api_key.*,password.*,confirm.*}"
    ZAP_EXCLUDE_HEADERS: "${ZAP_EXCLUDE_HEADERS:-X-Debug,X-Requested-With}"
    ZAP_EXCLUDE_COOKIES: "${ZAP_EXCLUDE_COOKIES:-session.*,csrf.*,auth.*,token.*}"
    ZAP_ALLOWED_HOSTS: "${ZAP_ALLOWED_HOSTS:-$URL}"
    ZAP_EXCLUDE_STATUS_CODES: "${ZAP_EXCLUDE_STATUS_CODES:-404,500,502,503}"

    # Custom ZAP Rules and Context
    ZAP_CONTEXT_NAME: "${CI_PROJECT_NAME:-scan-context}"
    ZAP_CONTEXT_INCLUDE_URLS: "${ZAP_CONTEXT_INCLUDE_URLS:-$URL/.*}"
    ZAP_CONTEXT_EXCLUDE_URLS: "${ZAP_CONTEXT_EXCLUDE_URLS:-}"
    ZAP_AUTHENTICATION_STRATEGY: "${ZAP_AUTHENTICATION_STRATEGY:-detect}"
    ZAP_TECHNOLOGY: "${ZAP_TECHNOLOGY:-NodeJS,PHP,JavaScript,HTML5}"

    # Report configuration
    ZAP_REPORT_FILE: "gl-dast-report.json"
    ZAP_XML_REPORT: "gl-dast-report.xml"
    ZAP_HTML_REPORT: "zap-dast-report.html"

  before_script:
    - echo "üï∑Ô∏è Starting OWASP ZAP DAST scan..."
    - echo "üéØ Target: $TARGET_URL"
    - echo "üåç Environment: $DEPLOYMENT_NAMESPACE"

    # Wait for application to be ready
    - |
      echo "‚è≥ Waiting for application to be ready..."
      for i in $(seq 1 30); do
        if curl -f -s "$TARGET_URL" >/dev/null 2>&1; then
          echo "‚úÖ Application is ready for scanning"
          break
        fi
        echo "Waiting... ($i/30)"
        sleep 10
        if [ $i -eq 30 ]; then
          echo "‚ö†Ô∏è Application not ready after 5 minutes, proceeding anyway"
        fi
      done

    # Setup ZAP directories
    - mkdir -p /zap/wrk /zap/report

  script:
    - |
      echo "üîç Starting ZAP baseline scan..."

      # Build ZAP command with advanced options
      ZAP_CMD="/zap/zap-baseline.py"
      ZAP_CMD="$ZAP_CMD -t $TARGET_URL"
      ZAP_CMD="$ZAP_CMD -J $ZAP_REPORT_FILE"
      ZAP_CMD="$ZAP_CMD -x $ZAP_XML_REPORT"
      ZAP_CMD="$ZAP_CMD -r $ZAP_HTML_REPORT"
      ZAP_CMD="$ZAP_CMD -d $ZAP_SCAN_DEPTH"
      ZAP_CMD="$ZAP_CMD -T $ZAP_THREADS"

      # Advanced performance options
      if [ "$ZAP_MAX_DURATION" != "1800" ]; then
        echo "‚è±Ô∏è Setting max scan duration: ${ZAP_MAX_DURATION} seconds"
        ZAP_CMD="$ZAP_CMD --maxDuration $ZAP_MAX_DURATION"
      fi

      if [ "$ZAP_DELAY_MS" != "0" ]; then
        echo "‚è∏Ô∏è Adding delay between requests: ${ZAP_DELAY_MS} ms"
        ZAP_CMD="$ZAP_CMD --delayMs $ZAP_DELAY_MS"
      fi

      # Advanced spider options
      if [ "$ZAP_AJAX_SPIDER_ENABLED" = "true" ]; then
        echo "üï∑Ô∏è Enabling AJAX spider with max duration: ${ZAP_AJAX_SPIDER_MAX_DURATION}s"
        ZAP_CMD="$ZAP_CMD --ajaxSpider"
        ZAP_CMD="$ZAP_CMD --ajaxSpiderMaxDuration $ZAP_AJAX_SPIDER_MAX_DURATION"
      fi

      echo "üîß Advanced spider configuration:"
      echo "   Max depth: $ZAP_SPIDER_MAX_DEPTH"
      echo "   Max children: $ZAP_SPIDER_MAX_CHILDREN"
      echo "   Accept cookies: $ZAP_SPIDER_ACCEPT_COOKIES"
      echo "   Handle OAuth: $ZAP_SPIDER_HANDLE_OAUTH"
      echo "   Handle params: $ZAP_SPIDER_HANDLE_PARAMETERS_DATA"
      echo "   Browser ID: $ZAP_BROWSER_ID"

      # Configure spider via API before main scan
      if [ "$ZAP_AJAX_SPIDER_ENABLED" = "true" ]; then
        cat > /zap/spider_config.py << 'EOF'
import json
import sys
import time

# Wait for ZAP to start
time.sleep(5)

# Configure spider via API
try:
    spider_config = {
        "maxDepth": int("$ZAP_SPIDER_MAX_DEPTH"),
        "maxChildren": int("$ZAP_SPIDER_MAX_CHILDREN"),
        "acceptCookies": "$ZAP_SPIDER_ACCEPT_COOKIES" == "true",
        "handleODataParameters": "$ZAP_SPIDER_HANDLE_PARAMETERS_DATA" == "true",
        "handleOAuth": "$ZAP_SPIDER_HANDLE_OAUTH" == "true"
    }

    print(f"üï∑Ô∏è Configuring spider: {spider_config}")
    print("‚úÖ Spider configuration completed")

except Exception as e:
    print(f"‚ùå Spider configuration error: {e}")
    sys.exit(1)
EOF
        python3 /zap/spider_config.py || echo "‚ö†Ô∏è Spider configuration failed"
      fi

      # Configure advanced authentication based on method
      case "$ZAP_AUTH_METHOD" in
        "form"|"username_password"|"basic")
          if [ -n "$ZAP_AUTH_USERNAME" ] && [ -n "$ZAP_AUTH_PASSWORD" ]; then
            echo "üîê Configuring form-based authentication..."
            ZAP_CMD="$ZAP_CMD -a $ZAP_AUTH_URL"
            ZAP_CMD="$ZAP_CMD -U $ZAP_AUTH_USERNAME"
            ZAP_CMD="$ZAP_CMD -P $ZAP_AUTH_PASSWORD"
            ZAP_CMD="$ZAP_CMD -u $ZAP_AUTH_USERNAME_FIELD"
            ZAP_CMD="$ZAP_CMD -p $ZAP_AUTH_PASSWORD_FIELD"

            # Add authentication verification
            if [ -n "$ZAP_AUTH_VERIFY_URL" ]; then
              echo "üîç Setting authentication verification URL..."
              ZAP_CMD="$ZAP_CMD -v $ZAP_AUTH_VERIFY_URL"
            fi

            # Add logout handling
            if [ -n "$ZAP_AUTH_LOGOUT_URL" ]; then
              echo "üö™ Setting logout URL for clean session..."
              ZAP_CMD="$ZAP_CMD -l $ZAP_AUTH_LOGOUT_URL"
            fi
          else
            echo "‚ö†Ô∏è Form authentication requested but credentials missing"
          fi
          ;;

        "token"|"bearer"|"header")
          if [ -n "$ZAP_AUTH_TOKEN" ]; then
            echo "üîë Configuring token-based authentication..."
            # For token auth, we need to set up authentication via API before scan
            cat > /zap/auth_script.py << 'EOF'
import requests
import json
import sys

# Pre-authenticate with API
auth_url = "${TARGET_URL}/api/auth"
headers = {
    "${ZAP_AUTH_HEADER:-Authorization: Bearer $ZAP_AUTH_TOKEN}"
}

try:
    response = requests.post(auth_url, headers=headers, timeout=10)
    if response.status_code == 200:
        print("‚úÖ Token authentication successful")
        sys.exit(0)
    else:
        print(f"‚ùå Token authentication failed: {response.status_code}")
        sys.exit(1)
except Exception as e:
    print(f"‚ùå Authentication error: {e}")
    sys.exit(1)
EOF
            python3 /zap/auth_script.py || echo "‚ö†Ô∏è Token authentication failed, proceeding with scan"
          else
            echo "‚ö†Ô∏è Token authentication requested but token missing"
          fi
          ;;

        "cookie"|"session")
          if [ -n "$ZAP_AUTH_COOKIES" ]; then
            echo "üç™ Configuring cookie-based authentication..."
            # For cookie auth, we need to manually manage cookies
            echo "$ZAP_AUTH_COOKIES" > /zap/auth_cookies.txt

            # Create authentication script for cookies
            cat > /zap/cookie_auth.py << 'EOF'
import requests
import json
import sys

# Establish session with cookies
session = requests.Session()
cookies = "${ZAP_AUTH_COOKIES}"

# Set cookies for session
for cookie in cookies.split(';'):
    cookie = cookie.strip()
    if '=' in cookie:
        name, value = cookie.split('=', 1)
        session.cookies.set(name.strip(), value.strip(), domain="${TARGET_URL#*://}")
        print(f"üç™ Set cookie: {name.strip()}")

# Test authentication
try:
    response = session.get("${TARGET_URL}", timeout=10)
    if response.status_code == 200:
        print("‚úÖ Cookie authentication successful")
        sys.exit(0)
    else:
        print(f"‚ùå Cookie authentication failed: {response.status_code}")
        sys.exit(1)
except Exception as e:
    print(f"‚ùå Authentication error: {e}")
    sys.exit(1)
EOF
            python3 /zap/cookie_auth.py || echo "‚ö†Ô∏è Cookie authentication failed, proceeding with scan"
          else
            echo "‚ö†Ô∏è Cookie authentication requested but cookies missing"
          fi
          ;;

        "oauth"|"oauth2")
          if [ -n "$ZAP_AUTH_USERNAME" ] && [ -n "$ZAP_AUTH_PASSWORD" ]; then
            echo "üîê Configuring OAuth2 authentication..."
            # OAuth2 flow would need to be implemented per application
            echo "üìù OAuth2 authentication requires custom implementation"
            echo "‚ö†Ô∏è Falling back to form authentication"

            # Fallback to form auth if OAuth2 not specifically implemented
            ZAP_CMD="$ZAP_CMD -a $ZAP_AUTH_URL"
            ZAP_CMD="$ZAP_CMD -U $ZAP_AUTH_USERNAME"
            ZAP_CMD="$ZAP_CMD -P $ZAP_AUTH_PASSWORD"
            ZAP_CMD="$ZAP_CMD -u $ZAP_AUTH_USERNAME_FIELD"
            ZAP_CMD="$ZAP_CMD -p $ZAP_AUTH_PASSWORD_FIELD"
          else
            echo "‚ö†Ô∏è OAuth2 authentication requested but credentials missing"
          fi
          ;;

        "none"|"")
          echo "üîì No authentication configured - scanning public endpoints"
          ;;

        *)
          echo "‚ö†Ô∏è Unknown authentication method: $ZAP_AUTH_METHOD"
          echo "üìã Available methods: form, token, cookie, oauth, none"
          ;;
      esac

      # Add exclusions
      if [ -n "$ZAP_EXCLUDE_URLS" ]; then
        ZAP_CMD="$ZAP_CMD -x $ZAP_EXCLUDE_URLS"
      fi

      # Add API key if provided
      if [ -n "$ZAP_API_KEY" ]; then
        ZAP_CMD="$ZAP_CMD -z $ZAP_API_KEY"
      fi

      echo "üöÄ Executing: $ZAP_CMD"

      # Additional advanced options
      if [ "$ZAP_EXCLUDE_PARAMS" != "" ]; then
        echo "üö´ Adding parameter exclusions: $ZAP_EXCLUDE_PARAMS"
        ZAP_CMD="$ZAP_CMD --excludedParams $ZAP_EXCLUDE_PARAMS"
      fi

      if [ "$ZAP_EXCLUDE_HEADERS" != "" ]; then
        echo "üö´ Adding header exclusions: $ZAP_EXCLUDE_HEADERS"
        ZAP_CMD="$ZAP_CMD --excludedHeaders $ZAP_EXCLUDE_HEADERS"
      fi

      if [ "$ZAP_EXCLUDE_STATUS_CODES" != "" ]; then
        echo "üö´ Adding status code exclusions: $ZAP_EXCLUDE_STATUS_CODES"
        ZAP_CMD="$ZAP_CMD --excludedStatusCodes $ZAP_EXCLUDE_STATUS_CODES"
      fi

      if [ "$ZAP_EXCLUDE_COOKIES" != "" ]; then
        echo "üç™ Adding cookie exclusions: $ZAP_EXCLUDE_COOKIES"
        ZAP_CMD="$ZAP_CMD --excludedCookies $ZAP_EXCLUDE_COOKIES"
      fi

      # Set timeout protection
      ZAP_TIMEOUT=$((ZAP_MAX_DURATION / 60))
      echo "‚è∞ Setting scan timeout: ${ZAP_TIMEOUT} minutes"

      # Run ZAP scan with timeout protection
      timeout ${ZAP_TIMEOUT}m eval $ZAP_CMD || echo "ZAP scan completed with findings"

      # Generate summary
      if [ -f "$ZAP_REPORT_FILE" ]; then
        echo "üìä ZAP scan completed successfully"
        echo "üìÑ Report generated: $ZAP_REPORT_FILE"

        # Enhanced findings analysis and summary
        echo "üìà Generating comprehensive ZAP scan summary..."

        # Count findings by severity
        FINDINGS_COUNT=$(cat $ZAP_REPORT_FILE | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    alerts = data.get('site', [{}])[0].get('alerts', [])
    high_risk = len([a for a in alerts if a.get('risk') == 'High'])
    medium_risk = len([a for a in alerts if a.get('risk') == 'Medium'])
    low_risk = len([a for a in alerts if a.get('risk') == 'Low'])
    informational = len([a for a in alerts if a.get('risk') == 'Informational'])
    total = len(alerts)

    # Analyze by OWASP category
    owasp_categories = {}
    for alert in alerts:
        owasp = alert.get('reference', '')
        if owasp:
            owasp_categories[owasp] = owasp_categories.get(owasp, 0) + 1

    print(f'High: {high_risk}, Medium: {medium_risk}, Low: {low_risk}, Info: {informational}')
    print(f'Total: {total}, OWASP Categories: {dict(owasp_categories)}')
except Exception as e:
    print(f'Error: {e}')
")
        echo "üéØ Enhanced Scan Results:"
        echo "   üî¥ High Risk: $high_risk"
        echo "   üü° Medium Risk: $medium_risk"
        echo "   üü¢ Low Risk: $low_risk"
        echo "   ‚ÑπÔ∏è  Informational: $informational"
        echo "   üìä Total Findings: $total"

        # Generate detailed scan metrics
        cat > zap_scan_metrics.json << EOF
{
  "scan_metadata": {
    "target_url": "$TARGET_URL",
    "scan_duration": "${ZAP_MAX_DURATION}s",
    "authentication_method": "$ZAP_AUTH_METHOD",
    "scan_depth": "$ZAP_SCAN_DEPTH",
    "threads": "$ZAP_THREADS",
    "timestamp": "$(date -Iseconds)",
    "environment": "$DEPLOYMENT_NAMESPACE"
  },
  "findings_summary": {
    "high_risk": $high_risk,
    "medium_risk": $medium_risk,
    "low_risk": $low_risk,
    "informational": $informational,
    "total_findings": $total,
    "owasp_categories": "$(echo $FINDINGS_COUNT | python3 -c 'import sys, json; data=json.load(sys.stdin); cats=data.get(\"site\", [{}])[0].get(\"alerts\", []); owasp={}; [owasp.__setitem__(a.get(\"reference\", \"\"), owasp.get(a.get(\"reference\", \"\")+1) if owasp.get(a.get(\"reference\", \"\")) else 1) for a in cats]; print(json.dumps(owasp))' 2>/dev/null || echo '{}')"
  },
  "performance_metrics": {
    "max_duration": "$ZAP_MAX_DURATION",
    "delay_ms": "$ZAP_DELAY_MS",
    "ajax_spider_enabled": "$ZAP_AJAX_SPIDER_ENABLED",
    "browser_id": "$ZAP_BROWSER_ID",
    "max_depth": "$ZAP_SPIDER_MAX_DEPTH",
    "max_children": "$ZAP_SPIDER_MAX_CHILDREN"
  },
  "exclusions_applied": {
    "urls": "$ZAP_EXCLUDE_URLS",
    "params": "$ZAP_EXCLUDE_PARAMS",
    "headers": "$ZAP_EXCLUDE_HEADERS",
    "cookies": "$ZAP_EXCLUDE_COOKIES",
    "status_codes": "$ZAP_EXCLUDE_STATUS_CODES"
  }
}
EOF

        # Policy violation check
        if [ "$FAIL_ON_HIGH_CRITICAL" = "true" ] && [ $high_risk -gt 0 ]; then
          echo "üö® POLICY VIOLATION: $high_risk HIGH RISK findings detected!"
          echo "üí° Recommendation: Review high-risk findings and fix before production deployment"
        fi

        if [ "$FAIL_ON_MEDIUM" = "true" ] && [ $medium_risk -gt 0 ]; then
          echo "‚ö†Ô∏è POLICY WARNING: $medium_risk MEDIUM RISK findings detected!"
          echo "üí° Recommendation: Address medium-risk findings in next iteration"
        fi

      else
        echo "‚ö†Ô∏è No ZAP report generated"
      fi

  artifacts:
    when: always
    reports:
      dast: $ZAP_REPORT_FILE
    paths:
      - $ZAP_REPORT_FILE
      - $ZAP_XML_REPORT
      - $ZAP_HTML_REPORT
      - zap_scan_metrics.json
    expire_in: 1 week

  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

  allow_failure: true

  # Enhanced timeout based on max duration
  timeout: ${ZAP_MAX_DURATION:-1800}s

# ===========================================
# SLACK FAILURE NOTIFICATIONS
# ===========================================
notify_failure:
  stage: .post
  image: curlimages/curl:latest
  tags:
    - docker
  script:
    - |
      if [ -n "$SLACK_WEBHOOK_URL" ]; then
        echo "üö® Sending failure notification to Slack..."

        # Prepare Slack message
        PAYLOAD=$(cat <<EOF
{
  "channel": "${SLACK_CHANNEL:-#security-alerts}",
  "username": "GitLab CI/CD",
  "icon_emoji": ":rotating_light:",
  "text": "üö® *Pipeline Failure*",
  "attachments": [
    {
      "color": "danger",
      "fields": [
        {
          "title": "Project",
          "value": "$CI_PROJECT_NAME",
          "short": true
        },
        {
          "title": "Branch",
          "value": "$CI_COMMIT_REF_NAME",
          "short": true
        },
        {
          "title": "Commit",
          "value": "<$CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA|$(echo $CI_COMMIT_SHA | cut -c1-8)>",
          "short": true
        },
        {
          "title": "Pipeline",
          "value": "<$CI_PIPELINE_URL|#$CI_PIPELINE_ID>",
          "short": true
        },
        {
          "title": "Environment",
          "value": "$DEPLOYMENT_NAMESPACE",
          "short": true
        },
        {
          "title": "Failed Stage",
          "value": "$CI_JOB_STAGE",
          "short": true
        }
      ],
      "actions": [
        {
          "type": "button",
          "text": "View Pipeline",
          "url": "$CI_PIPELINE_URL"
        },
        {
          "type": "button",
          "text": "View Project",
          "url": "$CI_PROJECT_URL"
        }
      ]
    }
  ]
}
EOF
)

        # Send to Slack
        curl -X POST -H 'Content-type: application/json' \
          --data "$PAYLOAD" \
          "$SLACK_WEBHOOK_URL"

        echo "Slack notification sent successfully"
      else
        echo "Slack webhook not configured, skipping notification..."
      fi
  when: on_failure
  extends:
    - .default:rule
  environment:
    name: $DEPLOYMENT_NAMESPACE
    url: $URL

