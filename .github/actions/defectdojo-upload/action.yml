name: 'DefectDojo Upload'
description: 'Upload security scan results to DefectDojo with auto-creation'
inputs:
  defectdojo-url:
    description: 'DefectDojo base URL (e.g., defectdojo.example.com)'
    required: true
  defectdojo-api-key:
    description: 'DefectDojo API key'
    required: true
  project-name:
    description: 'Project name in DefectDojo'
    required: true
  auto-create:
    description: 'Auto-create product and engagement'
    required: false
    default: 'true'
  engagement-name:
    description: 'Engagement name'
    required: false
    default: 'GitHub Actions CI/CD'
  reports-path:
    description: 'Path to security reports directory'
    required: false
    default: '.'
outputs:
  product-id:
    description: 'DefectDojo product ID'
    value: ${{ steps.upload.outputs.product-id }}
  engagement-id:
    description: 'DefectDojo engagement ID'
    value: ${{ steps.upload.outputs.engagement-id }}
  uploads-count:
    description: 'Number of successful uploads'
    value: ${{ steps.upload.outputs.uploads-count }}
runs:
  using: 'composite'
  steps:
    - name: ðŸ“¤ Upload to DefectDojo
      id: upload
      shell: bash
      run: |
        # Configuration
        DEFECTDOJO_URL="${{ inputs.defectdojo-url }}"
        DEFECTDOJO_API_KEY="${{ inputs.defectdojo-api-key }}"
        PROJECT_NAME="${{ inputs.project-name }}"
        AUTO_CREATE="${{ inputs.auto-create }}"
        ENGAGEMENT_NAME="${{ inputs.engagement-name }}"
        REPORTS_PATH="${{ inputs.reports-path }}"

        echo "ðŸ“¤ Uploading security reports to DefectDojo..."
        echo "   URL: $DEFECTDOJO_URL"
        echo "   Project: $PROJECT_NAME"
        echo "   Auto-create: $AUTO_CREATE"

        # Enhanced upload script for GitHub Actions
        cat > defectdojo-upload.py << 'EOF'
        #!/usr/bin/env python3

        import requests
        import json
        import os
        import sys
        from datetime import datetime

        class DefectDojoUploader:
            def __init__(self, base_url, api_key, product_name, engagement_name=None):
                self.base_url = base_url.rstrip('/')
                self.api_key = api_key
                self.product_name = product_name
                self.engagement_name = engagement_name or f"GitHub Actions CI/CD - {os.getenv('GITHUB_REF_NAME', 'main')}"
                self.headers = {
                    'Authorization': f'Token {api_key}',
                    'Content-Type': 'application/json'
                }

            def create_product_if_not_exists(self):
                """Create product if it doesn't exist and return product ID"""
                # Check if product exists
                search_url = f"{self.base_url}/api/v2/products/?name={self.product_name}"
                response = requests.get(search_url, headers=self.headers)

                if response.status_code == 200:
                    products = response.json().get('results', [])
                    if products:
                        product_id = products[0]['id']
                        print(f"âœ… Found existing product: {self.product_name} (ID: {product_id})")
                        return product_id

                # Create new product
                product_data = {
                    "name": self.product_name,
                    "description": f"Auto-created product for {self.product_name} - GitHub Actions",
                    "prod_type": 1,  # Web Application
                    "tags": ["github-actions", "automated", os.getenv('GITHUB_REPOSITORY', 'unknown').split('/')[-1]]
                }

                create_url = f"{self.base_url}/api/v2/products/"
                response = requests.post(create_url, headers=self.headers, json=product_data)

                if response.status_code == 201:
                    product_id = response.json()['id']
                    print(f"âœ… Created new product: {self.product_name} (ID: {product_id})")
                    return product_id
                else:
                    print(f"âŒ Failed to create product: {response.text}")
                    return None

            def create_engagement_if_not_exists(self, product_id):
                """Create engagement if it doesn't exist and return engagement ID"""
                # Check if engagement exists for this pipeline run
                engagement_date = datetime.now().strftime('%Y-%m-%d')
                search_url = f"{self.base_url}/api/v2/engagements/?name={self.engagement_name}&product={product_id}"
                response = requests.get(search_url, headers=self.headers)

                if response.status_code == 200:
                    engagements = response.json().get('results', [])
                    # Check for engagement with today's date
                    for eng in engagements:
                        if eng['target_start'].startswith(engagement_date):
                            print(f"âœ… Found existing engagement: {self.engagement_name} (ID: {eng['id']})")
                            return eng['id']

                # Create new engagement
                engagement_data = {
                    "name": self.engagement_name,
                    "description": f"Auto-created engagement for GitHub Actions pipeline run",
                    "product": product_id,
                    "target_start": datetime.now().isoformat(),
                    "target_end": datetime.now().isoformat(),
                    "status": "In Progress",
                    "engagement_type": "CI/CD",
                    "tags": ["github-actions", "automated", os.getenv('GITHUB_RUN_ID', 'unknown')]
                }

                create_url = f"{self.base_url}/api/v2/engagements/"
                response = requests.post(create_url, headers=self.headers, json=engagement_data)

                if response.status_code == 201:
                    engagement_id = response.json()['id']
                    print(f"âœ… Created new engagement: {self.engagement_name} (ID: {engagement_id})")
                    return engagement_id
                else:
                    print(f"âŒ Failed to create engagement: {response.text}")
                    return None

            def get_scan_type(self, file_name):
                """Determine scan type based on filename"""
                scan_types = {
                    'gitleaks.sarif': 'Gitleaks Scan',
                    'gitleaks.json': 'Gitleaks Scan',
                    'semgrep.sarif': 'Semgrep JSON Report',
                    'semgrep.json': 'Semgrep JSON Report',
                    'trivy-fs.sarif': 'Trivy Scan',
                    'trivy-fs.json': 'Trivy Scan',
                    'trivy-docker.sarif': 'Trivy Scan',
                    'trivy-docker.json': 'Trivy Scan',
                    'dependency-track-findings.json': 'Dependency-Track Scan',
                    'syft-sbom.cdx.json': 'Software Bill of Materials (SBOM)',
                    'docker-sbom.cdx.json': 'Software Bill of Materials (SBOM)',
                    'njsscan.sarif': 'SARIF',
                    'security-summary.json': 'Security Summary Report'
                }
                return scan_types.get(file_name, 'Generic Findings Import')

            def upload_report(self, file_path, engagement_id):
                """Upload a single report to DefectDojo"""
                if not os.path.exists(file_path) or os.path.getsize(file_path) == 0:
                    print(f"âš ï¸  File not found or empty: {file_path}")
                    return False

                scan_type = self.get_scan_type(os.path.basename(file_path))
                print(f"ðŸ“¤ Uploading {os.path.basename(file_path)} as {scan_type}")

                # Prepare upload data
                data = {
                    'active': True,
                    'verified': False,  # Let DefectDojo auto-verify
                    'scan_type': scan_type,
                    'minimum_severity': 'Low',
                    'engagement': engagement_id,
                    'lead': 1,  # Default lead
                    'environment': os.getenv('GITHUB_REF_NAME', 'Development'),
                    'version': os.getenv('GITHUB_SHA', 'unknown')[:8],
                    'build_id': os.getenv('GITHUB_RUN_ID', 'unknown'),
                    'commit_hash': os.getenv('GITHUB_SHA', 'unknown'),
                    'branch_tag': os.getenv('GITHUB_REF_NAME', 'main'),
                    'source_code_management_uri': os.getenv('GITHUB_SERVER_URL', '') + '/' + os.getenv('GITHUB_REPOSITORY', ''),
                    'deduplication_on_engagement': True
                }

                # Upload file
                upload_url = f"{self.base_url}/api/v2/import-scan/"

                try:
                    with open(file_path, 'rb') as f:
                        files = {'file': (os.path.basename(file_path), f, 'application/json')}
                        headers_upload = {'Authorization': f'Token {self.api_key}'}

                        response = requests.post(upload_url, headers=headers_upload, data=data, files=files)

                    if response.status_code == 201:
                        result = response.json()
                        print(f"âœ… Successfully uploaded {os.path.basename(file_path)} (Test ID: {result.get('test', 'N/A')})")
                        return True
                    else:
                        print(f"âŒ Failed to upload {os.path.basename(file_path)}: {response.status_code} - {response.text}")
                        return False

                except Exception as e:
                    print(f"âŒ Exception uploading {os.path.basename(file_path)}: {str(e)}")
                    return False

            def upload_all_reports(self, report_files):
                """Upload multiple reports to DefectDojo with auto-created product/engagement"""
                print(f"ðŸš€ Starting DefectDojo upload for {len(report_files)} reports")

                # Create or get product
                product_id = self.create_product_if_not_exists()
                if not product_id:
                    print("âŒ Failed to create/get product. Aborting uploads.")
                    return 0, None, None

                # Create or get engagement
                engagement_id = self.create_engagement_if_not_exists(product_id)
                if not engagement_id:
                    print("âŒ Failed to create/get engagement. Aborting uploads.")
                    return 0, product_id, None

                print(f"ðŸ“‹ Using Product ID: {product_id}, Engagement ID: {engagement_id}")

                # Upload all reports
                successful_uploads = 0
                failed_uploads = 0

                for report_file in report_files:
                    if self.upload_report(report_file, engagement_id):
                        successful_uploads += 1
                    else:
                        failed_uploads += 1

                print(f"\nðŸ“Š Upload Summary:")
                print(f"   âœ… Successful uploads: {successful_uploads}")
                print(f"   âŒ Failed uploads: {failed_uploads}")
                print(f"   ðŸ“ˆ Total files processed: {len(report_files)}")

                return successful_uploads, product_id, engagement_id

        if __name__ == "__main__":
            # Configuration from environment variables
            base_url = "$DEFECTDOJO_URL"
            api_key = "$DEFECTDOJO_API_KEY"
            product_name = "$PROJECT_NAME"

            # Default report files
            default_reports = [
                'gitleaks.sarif',
                'semgrep.sarif',
                'trivy-fs.sarif',
                'trivy-docker.sarif',
                'dependency-track-findings.json',
                'security-summary.json'
            ]

            # Check for available reports
            report_files = []
            for report in default_reports:
                if os.path.exists(report):
                    report_files.append(report)

            if not report_files:
                print("âš ï¸  No security report files found to upload")
                sys.exit(0)

            # Initialize uploader
            uploader = DefectDojoUploader(
                base_url=base_url,
                api_key=api_key,
                product_name=product_name
            )

            # Upload reports
            successful_uploads, product_id, engagement_id = uploader.upload_all_reports(report_files)

            if successful_uploads > 0:
                print("ðŸŽ‰ DefectDojo upload completed successfully!")
                # Set outputs for GitHub Actions
                print(f"::set-output name=product-id::{product_id}")
                print(f"::set-output name=engagement-id::{engagement_id}")
                print(f"::set-output name=uploads-count::{successful_uploads}")
                sys.exit(0)
            else:
                print("ðŸ’¥ DefectDojo upload failed!")
                sys.exit(1)
        EOF

        # Make script executable and run
        chmod +x defectdojo-upload.py
        python3 defectdojo-upload.py

        # Clean up
        rm -f defectdojo-upload.py